You are an expert in Next.js, TypeScript, Tailwind CSS, and modern web animation development.

Code Style and Structure
- Write concise, technical TypeScript code with accurate examples.
- Use functional and declarative programming patterns; avoid classes.
- Prefer iteration and modularization over code duplication.
- Use descriptive variable names with auxiliary verbs (e.g., isLoading, hasError).
- Structure files: exported component, subcomponents, helpers, static content, types.
- Follow Next.js 15 App Router conventions and best practices.

Naming Conventions
- Use lowercase with dashes for directories (e.g., components/layout-switcher).
- Use PascalCase for component files and functions.
- Favor named exports for components.
- Use descriptive names for GSAP animations and timelines.

TypeScript Usage
- Use TypeScript for all code; prefer interfaces over types.
- Avoid enums; use const objects instead.
- Use functional components with TypeScript interfaces.
- Use strict mode in TypeScript for better type safety.
- Define proper types for GSAP animations and refs.

Syntax and Formatting
- Use the "function" keyword for pure functions.
- Use arrow functions for event handlers and callbacks.
- Use declarative JSX with Tailwind CSS classes.
- Use Prettier for consistent code formatting.

UI and Styling
- Use shadcn/ui components for common UI patterns.
- Implement responsive design with Tailwind CSS breakpoints.
- Use CSS variables for theme colors and transitions.
- Implement dark mode support using Next.js and Tailwind.
- Ensure high accessibility (a11y) standards.
- Use GSAP for smooth animations and transitions.

Animation Guidelines
- Use useGSAP hook for GSAP animations.
- Scope animations to specific refs.
- Use contextSafe for event-based animations.
- Implement proper cleanup for animations.
- Use timelines for sequenced animations.
- Follow GSAP best practices for performance.

Performance Optimization
- Minimize the use of useState and useEffect.
- Use proper image optimization with Next.js Image component.
- Implement code splitting with dynamic imports.
- Profile and monitor performance using Next.js analytics.
- Avoid unnecessary re-renders using proper memoization.
- Optimize GSAP animations for performance.

Layout and Components
- Use Next.js App Router layout system.
- Implement proper metadata for SEO.
- Use layout variants for different section designs.
- Follow atomic design principles for components.
- Maintain consistent spacing and typography.

State Management
- Use React Context and useReducer for global state.
- Handle theme switching with proper state management.
- Manage layout variants state efficiently.
- Use proper state management for animations.

Error Handling and Validation
- Implement proper error boundaries.
- Handle animation errors gracefully.
- Use early returns for error conditions.
- Implement proper form validation.
- Handle edge cases in responsive layouts.

Testing
- Write unit tests using Jest and React Testing Library.
- Test animations and transitions.
- Implement visual regression testing.
- Test responsive layouts and theme switching.

Security
- Sanitize user inputs.
- Implement proper CSP headers.
- Secure form submissions.
- Follow Next.js security best practices.

Key Conventions
1. Use proper semantic HTML elements.
2. Follow mobile-first responsive design.
3. Maintain consistent animation patterns.
4. Use proper color contrast ratios.
5. Implement proper loading states.
6. Follow accessibility guidelines.
7. Maintain consistent component structure.
8. When generating mockup data, use extensive, realistic values and avoid using Lorem Ipsum.

API Documentation
- Next.js: https://nextjs.org/docs
- GSAP: https://greensock.com/docs/
- shadcn/ui: https://ui.shadcn.com/
- Tailwind CSS: https://tailwindcss.com/docs

Refer to the respective documentation for detailed information on components, animations, and styling best practices.

Component Layout Structure
- Organize sections in dedicated subfolders (e.g., Hero, About, Education).
- Create a Base component for each section to handle layout switching.
- Implement four distinct layout variants for each section:
  1. FirstVariant: Classic, clean layout
  2. SecondVariant: Modern, card-based design
  3. ThirdVariant: Interactive timeline/grid
  4. FourthVariant: Advanced interactive features

Base Component Pattern
- Use consistent naming: [Section]Base.tsx (e.g., HeroBase.tsx)
- Implement layout switching logic using useState
- Use LayoutSwitcher component for consistent UI
- Follow pattern:
  ```typescript
  export function SectionBase() {
    const [currentLayout, setCurrentLayout] = useState<Layout>("first");
    const handleLayoutChange = (layout: Layout) => {
      setCurrentLayout(layout);
    };

    const renderLayout = () => {
      switch (currentLayout) {
        case "first": return <FirstVariant />;
        case "second": return <SecondVariant />;
        // ... other variants
      }
    };

    return (
      <section className="relative">
        {renderLayout()}
        <LayoutSwitcher section="sectionName" onLayoutChange={handleLayoutChange} />
      </section>
    );
  }  ```

Layout Variant Guidelines
- Each variant should have unique features and animations
- Maintain consistent theming and responsiveness
- Accessible and mobile-friendly
- Follows modern design trends
- Follow naming convention: [Section][Variant].tsx (e.g., HeroFirst.tsx)
- Include:
  - Scoped GSAP animations using useGSAP
  - Proper ref management
  - Consistent component structure
  - Type definitions
  - Event handlers with contextSafe
  - Responsive design classes
  - Theme transitions

Folder Structure

src/
    components/
        sections/
            Hero/
                HeroBase.tsx
                FirstHero.tsx
                SecondHero.tsx
                ThirdHero.tsx
                FourthHero.tsx
            About/
                AboutBase.tsx
                FirstAbout.tsx
                SecondAbout.tsx
                ThirdAbout.tsx
                FourthAbout.tsx
// ... other sections follow same pattern
